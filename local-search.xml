<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>jdbc</title>
    <link href="/2024/07/16/jdbc%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/07/16/jdbc%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="JDBC理解学习与实现"><a href="#JDBC理解学习与实现" class="headerlink" title="JDBC理解学习与实现"></a>JDBC理解学习与实现</h1><p><strong>java database connectivity</strong></p><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3>]]></content>
    
    
    <categories>
      
      <category>-java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javaweb</title>
    <link href="/2024/07/14/javaweb/"/>
    <url>/2024/07/14/javaweb/</url>
    
    <content type="html"><![CDATA[<h3 id="1-javaweb学习路线"><a href="#1-javaweb学习路线" class="headerlink" title="1 javaweb学习路线"></a>1 javaweb学习路线</h3><p>关于系统结构分析<br>C&#x2F;S架构<br>特点：需要安装特定的客户端<br>      服务器压力小<br>      数据存储在客户端<br>缺点：升级更新困难<br>B&#x2F;S架构<br>特点：不需要安装特定的客户端<br>升级方便 只需要升级服务器  </p><h3 id="2-B-S架构的通信原理"><a href="#2-B-S架构的通信原理" class="headerlink" title="2 B&#x2F;S架构的通信原理"></a>2 B&#x2F;S架构的通信原理</h3>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaweb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql学习路线1</title>
    <link href="/2024/07/11/mysql%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF1/"/>
    <url>/2024/07/11/mysql%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF1/</url>
    
    <content type="html"><![CDATA[<h1 id="电路模电和这个哪个重要呢。。。"><a href="#电路模电和这个哪个重要呢。。。" class="headerlink" title="电路模电和这个哪个重要呢。。。"></a>电路模电和这个哪个重要呢。。。</h1><h3 id="1-sql的介绍（Structed-Query-Language）"><a href="#1-sql的介绍（Structed-Query-Language）" class="headerlink" title="1. sql的介绍（Structed Query Language）"></a>1. sql的介绍（Structed Query Language）</h3><p><strong>sql</strong>是一种管理和操作关系型数据库的一门语言。sql通过一系列数据库语句来进行增删改查和数据库控制操作。<br>插入 查询 增加 删除<br><strong>非关系型数据库</strong>  </p><h3 id="2-mysql连接及常用操作"><a href="#2-mysql连接及常用操作" class="headerlink" title="2. mysql连接及常用操作"></a>2. mysql连接及常用操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p<br><span class="hljs-keyword">show</span> databases;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>展示数据库<br>use your_database;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>选择数据库<br><span class="hljs-keyword">show</span> tables;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>展示数据表<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> your_table;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>选择所有列所有行<br><span class="hljs-keyword">drop</span> your_database;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除数据库<br></code></pre></td></tr></table></figure><h3 id="3-mysql增删改查"><a href="#3-mysql增删改查" class="headerlink" title="3 mysql增删改查"></a>3 mysql增删改查</h3><p>创建数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database runoob;<br></code></pre></td></tr></table></figure><p>删除数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> database runoob;<br></code></pre></td></tr></table></figure><p>创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> users (<br>    id <span class="hljs-type">INT</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY</span> KEY,<br>    username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    password <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>);<br></code></pre></td></tr></table></figure><p>删除表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> users;<br></code></pre></td></tr></table></figure><p>插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> users (username,password) <span class="hljs-keyword">values</span> (&quot;your_name&quot;,&quot;12345678&quot;);<br></code></pre></td></tr></table></figure><p>查询数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP 重载</title>
    <link href="/2024/06/02/test/"/>
    <url>/2024/06/02/test/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><!-- toc --><h1 id="cpp重载练习"><a href="#cpp重载练习" class="headerlink" title="cpp重载练习"></a>cpp重载练习</h1>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/03/31/acm/icpc/ccpc/cccc/"/>
    <url>/2024/03/31/acm/icpc/ccpc/cccc/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pytorch学习笔记</title>
    <link href="/2024/03/25/pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/03/25/pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>it is just my personal learning notes</p><span id="more"></span><p>入坑一下</p><h1 id="1-基本数据结构"><a href="#1-基本数据结构" class="headerlink" title="1. 基本数据结构"></a>1. 基本数据结构</h1><p>网上教程实在是杂乱无章<br><a href="https://wiki.python.org/moin/NumPy">numpy</a></p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java面向对象[二]</title>
    <link href="/2024/03/25/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%5B%E4%BA%8C%5D/"/>
    <url>/2024/03/25/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%5B%E4%BA%8C%5D/</url>
    
    <content type="html"><![CDATA[<h1 id="java进阶"><a href="#java进阶" class="headerlink" title="java进阶"></a><strong>java进阶</strong></h1><p>接口与抽象类辨析</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 抽象方法，隐式public abstract</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 抽象方法</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Bark&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Sleeping...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 抽象方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Sleeping...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Bark&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、内部类"><a href="#二、内部类" class="headerlink" title="二、内部类"></a>二、内部类</h3><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>定义在类内部，作为一个成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span> &#123;<br>        <span class="hljs-comment">// 内部类内容</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态内部类，使用static修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticInnerClass</span> &#123;<br>        <span class="hljs-comment">// 静态内部类内容</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>局部内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalInnerClass</span> &#123;<br>            <span class="hljs-comment">// 局部内部类内容</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;匿名内部类&quot;</span>);<br>            &#125;<br>        &#125;;<br>        r.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="三、枚举"><a href="#三、枚举" class="headerlink" title="三、枚举"></a>三、枚举</h3><h3 id="四、泛型"><a href="#四、泛型" class="headerlink" title="四、泛型"></a>四、泛型</h3>]]></content>
    
    
    <categories>
      
      <category>-java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java进阶面向对象[一]</title>
    <link href="/2024/03/22/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%5B%E4%B8%80%5D/"/>
    <url>/2024/03/22/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%5B%E4%B8%80%5D/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="面向对象详解"><a href="#面向对象详解" class="headerlink" title="面向对象详解"></a>面向对象详解</h2><p>借鉴java核心技术，一个宝藏教程</p><h2 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1.类和对象"></a>1.类和对象</h2><p>对象是类的一个实例，它具有状态和行为<br>类是一个模版，它定义一类对象  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">dog</span> &#123;<br>  string name;<br>  <span class="hljs-type">int</span> size;<br>  String color;<br>  <span class="hljs-type">int</span> age;<br>  <span class="hljs-keyword">void</span> run&#123;<br><br>  &#125;<br>  <span class="hljs-keyword">void</span> eat&#123;<br><br>  &#125;<br>  <span class="hljs-keyword">void</span> sleep&#123;<br>    <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/source/img/Java.png" alt="插图" title="Magic Gardens"></p><h2 id="2-封装"><a href="#2-封装" class="headerlink" title="2.封装"></a>2.封装</h2><p>封装：<br>Java中的封装（encapsulation）是指将类的实现细节隐藏起来，仅对外暴露必要的接口，从而实现了信息的隐藏和保护。  </p><p>封装通过访问控制修饰符来实现，Java中有四种访问控制修饰符：public、protected、default和private。  </p><p><strong>public</strong>修饰符表示公开，可以被类的内部、外部和子类访问；<br><strong>protected</strong>修饰符表示保护，可以被类的内部和外部子类访问；<br><strong>default</strong>表示包访问权限，仅限于同一包内的访问；<br><strong>private</strong>修饰符表示私有，仅限于本类内部访问。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//封装一个game类</span><br><span class="hljs-keyword">package</span> Game;<br><br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">game</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hurt;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> blood;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setname</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getBlood</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.blood;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setblood</span><span class="hljs-params">(<span class="hljs-type">int</span> blood)</span>&#123;<br>        <span class="hljs-built_in">this</span>.blood=blood;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">game</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> blood)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>        <span class="hljs-built_in">this</span>.blood=blood;<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-built_in">this</span>.hurt = random.nextInt(<span class="hljs-number">20</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">(game Game)</span><br>    &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name+<span class="hljs-string">&quot;使用了庐山升龙霸对&quot;</span>+Game.name+<span class="hljs-string">&quot;造成了&quot;</span>+<span class="hljs-built_in">this</span>.hurt+<span class="hljs-string">&quot;的伤害&quot;</span>);<br>        Game.blood=Game.blood-<span class="hljs-built_in">this</span>.hurt;<br>        <span class="hljs-keyword">if</span>(Game.blood&lt;<span class="hljs-number">0</span>)<br>        &#123;<br>            Game.blood=<span class="hljs-number">0</span>;<br>        &#125;<br>        System.out.println(Game.name+<span class="hljs-string">&quot;剩下了&quot;</span>+Game.blood+<span class="hljs-string">&quot;点&quot;</span>);<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>总结：<br>类与对象是Java中面向对象的两个重要概念。类是一种抽象数据类型，用于描述具有相同属性和行为的对象集合，它是创建对象的模板。对象则是类的一个实例，具有自己的状态（属性）和行为（方法）。</p><pre><code class="hljs">    在Java中，封装是指使用访问控制符限制类内部的数据和方法的访问范围，从而保证程序的安全性和健壮性。封装可以隐藏类的内部细节，只对外暴露必要的接口，增强了对程序的保护性。</code></pre><h2 id="3-抽象类和抽象方法"><a href="#3-抽象类和抽象方法" class="headerlink" title="3. 抽象类和抽象方法"></a>3. 抽象类和抽象方法</h2><p>抽象类和抽象方法是面向对象编程（OOP）中的两个重要概念，它们用于定义通用的接口和行为，同时允许具体的子类提供具体的实现。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>抽象类是一种不能被实例化的类，它提供了一个框架或模板，供其他类继承。抽象类可以包含抽象方法（没有实现的方法）和具体方法（有实现的方法）。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><strong>不能实例化</strong>：你不能创建一个抽象类的对象。</li><li><strong>可以包含抽象方法和具体方法</strong>：抽象类可以包含没有实现的抽象方法，以及具有实现的具体方法。</li><li><strong>子类必须实现抽象方法</strong>：任何继承抽象类的子类都必须实现所有的抽象方法，除非子类也是抽象类。</li></ol><h3 id="示例（Java）"><a href="#示例（Java）" class="headerlink" title="示例（Java）"></a>示例（Java）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">// 抽象方法，没有实现</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 具体方法，有实现</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Sleeping...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Bark&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Animal</code>是一个抽象类，包含一个抽象方法<code>makeSound()</code>和一个具体方法<code>sleep()</code>。<code>Dog</code>类继承<code>Animal</code>类，并实现了<code>makeSound()</code>方法。</p><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>抽象方法是没有方法体的方法，仅有方法签名，用于在抽象类中声明。抽象方法要求子类必须提供其实现。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol><li><strong>没有方法体</strong>：抽象方法只有方法签名，没有方法体。</li><li><strong>必须在抽象类中声明</strong>：抽象方法只能在抽象类中声明。</li><li><strong>子类必须实现</strong>：继承抽象类的子类必须实现所有的抽象方法，除非子类也是抽象类。</li></ol><h3 id="示例（Python）"><a href="#示例（Python）" class="headerlink" title="示例（Python）"></a>示例（Python）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">抽象类 Animal<br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">// 抽象方法，没有方法体</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 具体方法，有方法体</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Sleeping...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体类 Dog 继承自抽象类 Animal</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">// 实现抽象方法 makeSound</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Bark&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 不能实例化抽象类</span><br>        <span class="hljs-comment">// Animal animal = new Animal(); // 编译错误</span><br><br>        <span class="hljs-comment">// 实例化具体类 Dog</span><br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        dog.makeSound(); <span class="hljs-comment">// 输出：Bark</span><br>        dog.sleep();     <span class="hljs-comment">// 输出：Sleeping...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="为什么需要抽象类和抽象方法？"><a href="#为什么需要抽象类和抽象方法？" class="headerlink" title="为什么需要抽象类和抽象方法？"></a>为什么需要抽象类和抽象方法？</h2><h3 id="1-定义通用接口"><a href="#1-定义通用接口" class="headerlink" title="1. 定义通用接口"></a>1. <strong>定义通用接口</strong></h3><p>抽象类和抽象方法允许你定义一个通用接口，而不具体实现细节。这样，多个子类可以实现相同的接口，从而保证代码的一致性和可维护性。</p><h3 id="2-代码复用"><a href="#2-代码复用" class="headerlink" title="2. 代码复用"></a>2. <strong>代码复用</strong></h3><p>通过在抽象类中定义具体方法，子类可以继承和重用这些方法，减少代码重复，提高代码复用性。</p><h3 id="3-强制约束"><a href="#3-强制约束" class="headerlink" title="3. 强制约束"></a>3. <strong>强制约束</strong></h3><p>抽象类强制子类实现特定的方法，这样可以确保子类具有某些行为或功能，从而提高代码的可靠性和可预测性。</p><h3 id="4-灵活性"><a href="#4-灵活性" class="headerlink" title="4. 灵活性"></a>4. <strong>灵活性</strong></h3><p>抽象类允许你在某些情况下提供默认的实现，同时在其他情况下强制子类提供具体的实现，从而提高代码的灵活性和扩展性。</p>]]></content>
    
    
    <categories>
      
      <category>-java -编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>西电软工复试</title>
    <link href="/2024/03/21/%E5%A4%8D%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/03/21/%E5%A4%8D%E8%AF%95%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>it is just my personal learning notes</p><span id="more"></span><h1 id="总得来说-问的比较贴合课本-考察考生基础"><a href="#总得来说-问的比较贴合课本-考察考生基础" class="headerlink" title="总得来说 问的比较贴合课本 考察考生基础"></a>总得来说 问的比较贴合课本 考察考生基础</h1><h3 id="1-什么是多线程？-什么是反馈？"><a href="#1-什么是多线程？-什么是反馈？" class="headerlink" title="1 什么是多线程？ 什么是反馈？"></a>1 什么是多线程？ 什么是反馈？</h3><p>答：多线程是指在软件或硬件中实现多个线程并发执行的技术，在同一程序中，可以同时运行多个线程，可以独立执行不同的任务，从而提高系统的执行效率和并发性。<br>反馈是指系统输出的一部分或者全部重新加到输入端对输出产生作用</p><p><img src="/source/img/nana.png" alt="插图" title="Magic Gardens"></p><h3 id="2-解释TCP-IP的拥塞控制过程"><a href="#2-解释TCP-IP的拥塞控制过程" class="headerlink" title="2 解释TCP&#x2F;IP的拥塞控制过程"></a>2 解释TCP&#x2F;IP的拥塞控制过程</h3><p>答：某段时间内，网络中对某种资源的请求超过了所能提供的部分，就会出现拥塞的现象。<br>慢开始：<br>目的:在连接开始的时候迅速找到网络容量，避免数据大量涌入<br>拥塞避免：<br>目的：避免发生拥塞并稳步提高传输速率。<br>快重传：<br>目的：在检测到丢包时快速重新传输丢失的数据包，而不必等待超时。<br>快恢复：<br>目的：<br>在检测到丢包后迅速恢复传输速率，而不是重新进入慢启动。<br>   cwnd<br>     |<br>     |                           &#x2F;<br>     |                          &#x2F;<br>     |                         &#x2F;<br>     |                        &#x2F;<br>     |                       &#x2F;<br>     |                      &#x2F;<br>     |                     &#x2F;<br>     |                    &#x2F;<br>     |                   &#x2F;<br>     |                  &#x2F;<br>     |_________________&#x2F;<br>     |                 ^<br>     |                 |<br>     +————————-&gt;  time<br>     Slow Start      Congestion Avoidance</p><h3 id="3-TCP-IP协议和UDP协议的区别"><a href="#3-TCP-IP协议和UDP协议的区别" class="headerlink" title="3 TCP&#x2F;IP协议和UDP协议的区别"></a>3 TCP&#x2F;IP协议和UDP协议的区别</h3><p>tcp&#x2F;ip:<br>面向连接：在数据传输前需要建立连接，保证数据传输的可靠性。<br>有序性：确保数据按顺序到达。<br>有确认机制：发送方会等待接收方的确认，保证数据的准确送达。<br>相对复杂，开销较大。<br>udp：<br>无连接：不需要事先建立连接，数据发送较为简单、快速。<br>不保证有序性和可靠性，可能出现数据丢失、乱序，但效率高。<br>实时性较好：适用于对实时性要求较高而对数据准确性要求相对不那么高的场景。<br>简单轻便，开销较小。  </p><h3 id="4-什么是中断以及中断处理的过程"><a href="#4-什么是中断以及中断处理的过程" class="headerlink" title="4 什么是中断以及中断处理的过程"></a>4 什么是中断以及中断处理的过程</h3><p>中断（Interrupt）是一种异步信号，用于通知处理器需要处理某个事件。中断可以由硬件设备或软件异常触发，当中断发生时，处理器暂停当前执行的任务，保存当前状态，转而处理中断事件。处理完中断事件后，处理器恢复之前保存的状态，继续执行之前的任务。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">vi /etc/config/network<br></code></pre></td></tr></table></figure><h3 id="5-介绍两到三种排序方法"><a href="#5-介绍两到三种排序方法" class="headerlink" title="5 介绍两到三种排序方法"></a>5 介绍两到三种排序方法</h3><p>冒泡排序：<br>两两交换，最大一个排到末尾，共重复n-1次，时间复杂度o(n<sup>2</sup>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>&#125;;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span><span class="hljs-number">-1</span>;i++)<br>   &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">10</span>-i<span class="hljs-number">-1</span>;j++)<br>    &#123;<br>      。。。<br>    &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入排序：<br>待排序的数字按照值的大小插入到前面已经有序的队列中去。时间复杂度o(n<sup>2</sup>)    </p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java笔记汇总</title>
    <link href="/2024/03/08/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%88%9D%E7%BA%A7/"/>
    <url>/2024/03/08/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%88%9D%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="it-is-just-my-personal-learning-notes-1序言回想自从系统学完C语言后，很少在系统学一门编程语言，python听得时候天天摆烂，以至于学完了还是一团浆糊，直到大二开始在leetcode刷题才有所深入了解，看来学习还是得付诸于时间才行。正好这段时间在经营博客，有事没事往上面扔点东西，挺好的"><a href="#it-is-just-my-personal-learning-notes-1序言回想自从系统学完C语言后，很少在系统学一门编程语言，python听得时候天天摆烂，以至于学完了还是一团浆糊，直到大二开始在leetcode刷题才有所深入了解，看来学习还是得付诸于时间才行。正好这段时间在经营博客，有事没事往上面扔点东西，挺好的" class="headerlink" title="it is just my personal learning notes# 1序言回想自从系统学完C语言后，很少在系统学一门编程语言，python听得时候天天摆烂，以至于学完了还是一团浆糊，直到大二开始在leetcode刷题才有所深入了解，看来学习还是得付诸于时间才行。正好这段时间在经营博客，有事没事往上面扔点东西，挺好的  "></a>it is just my personal learning notes<br><span id="more"></span><br># 1序言<br>回想自从系统学完C语言后，很少在系统学一门编程语言，python听得时候天天摆烂，以至于学完了还是一团浆糊，直到大二开始在leetcode刷题才有所深入了解，看来学习还是得付诸于时间才行。<br>正好这段时间在经营博客，有事没事往上面扔点东西，挺好的  </h2><!-- toc --><h1 id="2-java基本内容"><a href="#2-java基本内容" class="headerlink" title="2 java基本内容"></a>2 java基本内容</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>官方白皮书给出了如下关键字：简单性（接近C++）、面向对象（支持多重继承）、分布式、健壮性（优秀的指针模型）、安全性（复杂的安全模型）、体系结构中立（Java虚拟机）、可移植性（众多平台独立的Java库）、解释型（轻量的编译过程）、高性能（即时编译器）、多线程、动态性。</p><h2 id="2-2-java的程序结构"><a href="#2-2-java的程序结构" class="headerlink" title="2.2 java的程序结构"></a>2.2 java的程序结构</h2><p>java程序是以类为单位的，类则是一种自定义数据结构（类似于C中的结构体struct）。上面的程序包含了一个public类型的class（类），Hello是这个类的类名，这名称需和文件名同名。和C语言一样，Java也是大小写敏感的。习惯上将类名的每个单词首字母大写。  </p><p>这个类中包含了一个main方法（也就是函数），作为这个Java程序的运行起点。这个方法中包含了该程序的所有逻辑，和C非常相似。</p><h2 id="2-3数据类型"><a href="#2-3数据类型" class="headerlink" title="2.3数据类型"></a>2.3数据类型</h2><p>java跟c&#x2F;c++一样，数据元素有不同的数据类型<br>整型:byte(1字节),short(2个字节),int(4个字节),long(8个字节)<br>浮点类型:float(4字节),double(8字节)<br>字符类型 char<br>布尔类型 boolean  </p><h2 id="2-4输入输出"><a href="#2-4输入输出" class="headerlink" title="2.4输入输出"></a>2.4输入输出</h2><p>这点我认为java比较繁琐<br>首先头文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br></code></pre></td></tr></table></figure><p>输入输出  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.println(in.nextInt());<br>System.out.println(in.nextLine());<br></code></pre></td></tr></table></figure><h2 id="2-5-流程控制"><a href="#2-5-流程控制" class="headerlink" title="2.5 流程控制"></a>2.5 流程控制</h2><p>流程控制<br>Java中也有块（block）的概念。大多数内容都和C一致，除了嵌套的块中不能声明重名变量。下面说一下流程控制语句：  </p><p>if-else if-else 和C一样<br>while&#x2F;do-while 和C一样<br>for 和C一样。不过添加了一种for each循环<br>switch 和C一样。不过从Java SE 7 开始，case标签可以是字符串字面量<br>break 后面可以带标签，用法和C中的goto一样。不过只能跳出语句块而不能跳入<br>continue 和C一样  </p><h2 id="2-6-高精度算法-大数值"><a href="#2-6-高精度算法-大数值" class="headerlink" title="2.6 高精度算法(大数值)"></a>2.6 高精度算法(大数值)</h2><p>这个是一个可以说说的话题，还记着我大一下有门程序设计课，大作业就是完成各种常见的数据结构，其中就有一个高精度算法的C语言实现，但当时gpt水水就完事了，内在逻辑一点不清楚，看acwing的时候，惊奇听人说python一行就完事儿。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())*<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>()))<br></code></pre></td></tr></table></figure><p>注意这里是分行输入 看来以后还得写篇python<br>而java的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigInterger</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> BigInterger.valueOf(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><h2 id="2-7-数组"><a href="#2-7-数组" class="headerlink" title="2.7 数组"></a>2.7 数组</h2><p>这个东西还挺烦人，刚学的时候一直记不住</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> []ss = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [<span class="hljs-number">100</span>]<span class="hljs-comment">//和cpp不一样的是，[]在前面写着</span><br><span class="hljs-type">int</span> []ss = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;;<br>a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>技术文档修改版</title>
    <link href="/2024/03/02/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    <url>/2024/03/02/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>Obsdian first try </p><span id="more"></span><h1>lalalalaalaa</h1><p><strong>markdown</strong><br><em>markdown</em></p><h1>我怀念的，是无话不说</h1><h1>this is a heading</h1>在Python语言中最常见的括号有三种，分别是：小括号（）、中括号[]、花括号{}；其作用也不相同，分别用来代表不同的Python基本内置数据类型。<p>Python中的小括号（）：</p><p>代表tuple元祖数据类型，元祖是一种不可变序列。创建方法很简单，大多数时候都是小括号括起来的</p><p>1 &gt;&gt;&gt; tup &#x3D; (1,2,3)<br>2 &gt;&gt;&gt; tup<br>3 (1, 2, 3)<br>4 &gt;&gt;&gt; () #空元祖<br>5 ()<br>6 &gt;&gt;&gt; 55,#一个值的元祖<br>7 (55,)</p><p>Python中的中括号[]：</p><p>代表list列表数据类型，列表是一种可变序列。创建方法既简单又特别。</p><p>原来list（）是调用函数啊，这样我就好理解的，那意思就是list(‘ABC’)，调用了list这个函数，ABC就形成了一个有3个元素的列表，其中三个元素分别是A、B、C，而X&#x3D;[‘ABC’]，是本身列了一个列表，里面只有一个元素，元素是ABC</p><p>1 &gt;&gt;&gt; list(‘Python’)<br>2 [‘P’, ‘y’, ‘t’, ‘h’, ‘o’, ‘n’]  </p><p>那如果我要用调用list函数表示一个列表，里面只有一个元素，元素是ABC，怎么表示呢<br> list([‘ABC’])<br>Python中的花括号{}：</p><p>代表dict字典数据类型，字典是Python中唯一内建的映射类型。字典中的值没有特殊的顺序，但都是存储在一个特定的键（key）下。键可以是数字、字符串甚至是元祖。</p><p>1 &gt;&gt;&gt; dic &#x3D; {‘jon’:’boy’,’lili”‘:’girl’}<br>2 &gt;&gt;&gt; dic<br>3 {‘jon’: ‘boy’, ‘lili”‘: ‘girl’}<br>[[我也是一个笔记]]<br>我要讲到的是[[垃圾回收]]</p>]]></content>
    
    
    <categories>
      
      <category>markdown测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>文档</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP STL</title>
    <link href="/2024/03/02/stl/"/>
    <url>/2024/03/02/stl/</url>
    
    <content type="html"><![CDATA[<p>STL的用法 方便自己回看</p><span id="more"></span><!-- toc --><h1 id="1-vector-变长数组"><a href="#1-vector-变长数组" class="headerlink" title="1. vector(变长数组)"></a>1. vector(变长数组)</h1><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt;ss;<span class="hljs-comment">//一维数组</span><br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">ss</span>(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<span class="hljs-comment">//n+1个0元素</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;ss;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;ss[<span class="hljs-number">5</span>]<span class="hljs-comment">//行不可变 列可变长数组</span><br></code></pre></td></tr></table></figure><h3 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>; <span class="hljs-comment">// 两个数组中的类型必须相同,a和b都是长度为n+1，初始值都为0的数组</span><br>vector&lt;<span class="hljs-type">int</span>&gt; c = a; <span class="hljs-comment">// 也是拷贝初始化,c和a是完全一样的数组</span><br></code></pre></td></tr></table></figure><p>vector<int> v[5]可以这样理解：长度为5的v数组，数组中存储的是vector<int> 数据类型，而该类型就是数组形式，故v为二维数组。其中每个数组元素均为空，因为没有指定长度，所以第二维可变长。可以进行下述操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">v[<span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>v[<span class="hljs-number">2</span>].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h1 id="1-2-函数方法"><a href="#1-2-函数方法" class="headerlink" title="1.2 函数方法"></a>1.2 函数方法</h1><p>STL的函数方法一般分为删除、添加、查找。<br>以数组ss举例  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ss.<span class="hljs-built_in">front</span>()<span class="hljs-comment">//展示ss的第一个元素</span><br>ss.<span class="hljs-built_in">front</span>()<span class="hljs-comment">//展示ss的最后一个元素</span><br>ss.<span class="hljs-built_in">push_back</span>(element)<span class="hljs-comment">//向数组末尾添加一个元素</span><br>ss.<span class="hljs-built_in">size</span>()返回实际数据个数（<span class="hljs-type">unsigned</span>类型）  <br>ss.<span class="hljs-built_in">clear</span>()清除元素个数<span class="hljs-built_in">O</span> ( N ) <span class="hljs-built_in">O</span>(N)<span class="hljs-built_in">O</span>(N)，N为元素个数<br>ss.<span class="hljs-built_in">resize</span>(n, v)改变数组大小为n,n个空间数值赋为v，如果没有默认赋值为<span class="hljs-number">0</span>  <br>ss.<span class="hljs-built_in">insert</span>(it, x)向任意迭代器it插入一个元素x  <br>例：ss.<span class="hljs-built_in">insert</span>(ss.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">2</span>,<span class="hljs-number">-1</span>)将<span class="hljs-number">-1</span>插入ss[<span class="hljs-number">2</span>]的位置<br>ss.<span class="hljs-built_in">erase</span>(first,last)删除[first,last)的所有元素  <br>ss.<span class="hljs-built_in">begin</span>()返回首元素的迭代器（通俗来说就是地址）  <br>ss.<span class="hljs-built_in">end</span>()返回最后一个元素后一个位置的迭代器（地址）  <br>ss.<span class="hljs-built_in">empty</span>()判断是否为空，为空返回真，反之返回假  <br></code></pre></td></tr></table></figure><h1 id="1-3数组的访问"><a href="#1-3数组的访问" class="headerlink" title="1.3数组的访问"></a>1.3数组的访问</h1><h3 id="1-3-1-下标访问"><a href="#1-3-1-下标访问" class="headerlink" title="1.3.1 下标访问"></a>1.3.1 下标访问</h3><p>和正常数组一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ss.<span class="hljs-built_in">size</span>(); i++)&#123;<br>  cout&lt;&lt;ss[i];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-2-迭代器访问"><a href="#1-3-2-迭代器访问" class="headerlink" title="1.3.2 迭代器访问"></a>1.3.2 迭代器访问</h3><p>不细说了</p><h3 id="1-3-3-智能指针访问"><a href="#1-3-3-智能指针访问" class="headerlink" title="1.3.3 智能指针访问"></a>1.3.3 智能指针访问</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val : v) &#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">//s[0],s[1]...</span><br>&#125;<br></code></pre></td></tr></table></figure><!-- toc --><h1 id="2-stack"><a href="#2-stack" class="headerlink" title="2. stack"></a>2. stack</h1><p>-<del>这是分割线</del></p><h2 id="1-1-stack"><a href="#1-1-stack" class="headerlink" title="1.1 stack"></a>1.1 stack</h2><p>栈为数据结构的一种，是STL中实现的一个先进后出，后进先出的容器  </p><p>头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br></code></pre></td></tr></table></figure><p>初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">stack&lt;<span class="hljs-type">int</span>&gt;ss;<br>stack&lt;<span class="hljs-type">char</span>&gt;ss;<br>stack&lt;listnode*&gt;ss;<br></code></pre></td></tr></table></figure><h2 id="1-2-方法函数"><a href="#1-2-方法函数" class="headerlink" title="1.2 方法函数"></a>1.2 方法函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ss.<span class="hljs-built_in">push</span>(element);<br>ss.<span class="hljs-built_in">pop</span>();<br>ss.<span class="hljs-built_in">top</span>();<br>ss.<span class="hljs-built_in">empty</span>();<br>ss.<span class="hljs-built_in">size</span>();<br></code></pre></td></tr></table></figure><h2 id="1-3-函数访问"><a href="#1-3-函数访问" class="headerlink" title="1.3 函数访问"></a>1.3 函数访问</h2><hr><!-- toc --><h1 id="3-queue"><a href="#3-queue" class="headerlink" title="3. queue"></a>3. queue</h1><h2 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h2><p>queue即队列，是一种基本数据结构类型，在一些算法中有妙用，比如著名的bfs广度优先算法，嗯嗯 先进先出</p><h2 id="1-2-方法函数-1"><a href="#1-2-方法函数-1" class="headerlink" title="1.2 方法函数"></a>1.2 方法函数</h2><p>假设ss是一个队列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ss.<span class="hljs-built_in">push</span>(ele);<br>ss.<span class="hljs-built_in">pop</span>();<br>ss.<span class="hljs-built_in">front</span>();<br>ss.<span class="hljs-built_in">back</span>();<br>ss.<span class="hljs-built_in">size</span>();<br>ss.<span class="hljs-built_in">empty</span>();<br></code></pre></td></tr></table></figure><h2 id="1-3-优先队列"><a href="#1-3-优先队列" class="headerlink" title="1.3 优先队列"></a>1.3 优先队列</h2><p>这个确实需要单独来提一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt; &gt;ss;<span class="hljs-comment">//升序队列  </span><br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,less&lt;<span class="hljs-type">int</span>&gt; &gt;ss;<span class="hljs-comment">//降序队列  </span><br></code></pre></td></tr></table></figure><p>sla在实现哈夫曼树算法时有妙用，感觉应该也有其他用处sla</p><h1 id="4-string字符串"><a href="#4-string字符串" class="headerlink" title="4 string字符串"></a>4 string字符串</h1><p>$\vec{a}$<br>字符串string是一个字符串类，和char型字符串类似。<br>可以把string理解为一个字符串类型，像int一样可以定义  </p><h2 id="1-1-初始化及定义"><a href="#1-1-初始化及定义" class="headerlink" title="1.1 初始化及定义"></a>1.1 初始化及定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">//1.</span><br>string str1; <span class="hljs-comment">//生成空字符串</span><br><br><span class="hljs-comment">//2.</span><br><span class="hljs-function">string <span class="hljs-title">str2</span><span class="hljs-params">(<span class="hljs-string">&quot;123456789&quot;</span>)</span></span>; <span class="hljs-comment">//生成&quot;1234456789&quot;的复制品 </span><br><br><span class="hljs-comment">//3.</span><br><span class="hljs-function">string <span class="hljs-title">str3</span><span class="hljs-params">(<span class="hljs-string">&quot;12345&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>)</span></span>;<span class="hljs-comment">//结果为&quot;123&quot; ，从0位置开始，长度为3</span><br><br><span class="hljs-comment">//4.</span><br><span class="hljs-function">string <span class="hljs-title">str4</span><span class="hljs-params">(<span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">//结果为&quot;12345&quot; ，长度为5</span><br><br><span class="hljs-comment">//5.</span><br><span class="hljs-function">string <span class="hljs-title">str5</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;2&#x27;</span>)</span></span>; <span class="hljs-comment">//结果为&quot;22222&quot; ,构造5个字符&#x27;2&#x27;连接而成的字符串</span><br><br><span class="hljs-comment">//6.</span><br><span class="hljs-function">string <span class="hljs-title">str6</span><span class="hljs-params">(str2, <span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">//结果为&quot;3456789&quot;，截取第三个元素（2对应第三位）到最后</span><br></code></pre></td></tr></table></figure><h2 id="1-2-函数方法-1"><a href="#1-2-函数方法-1" class="headerlink" title="1.2 函数方法"></a>1.2 函数方法</h2><p>插入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ss.<span class="hljs-built_in">push_back</span>(ele);<span class="hljs-comment">//字符串尾部加元素</span><br>ss.<span class="hljs-built_in">insert</span>(pos,ele);<span class="hljs-comment">//在pos位置添加元素</span><br>ss.<span class="hljs-built_in">append</span>(str)<span class="hljs-comment">//尾部添加字符串</span><br></code></pre></td></tr></table></figure><p>长度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ss.<span class="hljs-built_in">size</span>()  ss.<span class="hljs-built_in">length</span>()<br>ss.<span class="hljs-built_in">max_size</span>()<br></code></pre></td></tr></table></figure><h2 id="1-3-stirng的读入"><a href="#1-3-stirng的读入" class="headerlink" title="1.3 stirng的读入"></a>1.3 stirng的读入</h2><p>这里让我想到机考的时候字符串没处理换行符导致的bug</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  string ss;<br>  cin&gt;&gt;n;<br>  <span class="hljs-built_in">getchar</span>();<br>  ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-map映射"><a href="#5-map映射" class="headerlink" title="5 map映射"></a>5 map映射</h1><h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><p>map类似映射，在做leetcode题时用unordered_map表示哈希表？<br>定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br>map&lt;string,<span class="hljs-type">int</span>&gt;ss;<br>map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;ss;<br>map&lt;string,node&gt;ss;<span class="hljs-comment">//node是结构体</span><br></code></pre></td></tr></table></figure><p>map特性：map会按照键的顺序从小到大自动排序，键的类型必须可以比较大小<br>好像map可以用来表示二维数组</p><h2 id="5-2-方法"><a href="#5-2-方法" class="headerlink" title="5.2 方法"></a>5.2 方法</h2><h1 id="6-pair"><a href="#6-pair" class="headerlink" title="6 pair"></a>6 pair</h1><h2 id="6-1"><a href="#6-1" class="headerlink" title="6.1"></a>6.1</h2><p>好像记错pair和map了<br>只有两个元素 可以代替二元结构体<br>作为map键值对进行插入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-comment">//1.初始化定义</span><br><span class="hljs-function">pair&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;wan&quot;</span>,<span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">//带初始值的</span><br>pair&lt;string, <span class="hljs-type">int</span>&gt; p;<span class="hljs-comment">//不带初始值的</span><br>pair&lt;string,<span class="hljs-type">int</span>&gt;ss;<br><span class="hljs-comment">//2.赋值</span><br>p = &#123;<span class="hljs-string">&quot;wang&quot;</span>, <span class="hljs-number">18</span>&#125;;<br>p = <span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;wang&quot;</span>, <span class="hljs-number">18</span>);<br>ss=(<span class="hljs-string">&quot;sss&quot;</span>,<span class="hljs-number">11</span>);<br>p = <span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">int</span>&gt;(<span class="hljs-string">&quot;wang&quot;</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><h2 id="6-2-访问"><a href="#6-2-访问" class="headerlink" title="6.2 访问"></a>6.2 访问</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;ss[<span class="hljs-number">20</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++ )&#123;<br>  cout&lt;&lt;p[i].first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p[i].second;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7-set集合"><a href="#7-set集合" class="headerlink" title="7 set集合"></a>7 set集合</h1><h2 id="7-1定义"><a href="#7-1定义" class="headerlink" title="7.1定义"></a>7.1定义</h2><p>set容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序。<br>即：set里面的元素不重复 且有序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br>set&lt;<span class="hljs-type">int</span>&gt;ss;<br></code></pre></td></tr></table></figure><h2 id="7-2函数方法"><a href="#7-2函数方法" class="headerlink" title="7.2函数方法"></a>7.2函数方法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s.<span class="hljs-built_in">begin</span>()返回set容器的第一个元素的地址（迭代器）<span class="hljs-built_in">O</span> ( <span class="hljs-number">1</span> ) <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<br>s.<span class="hljs-built_in">end</span>()返回set容器的最后一个元素的下一个地址（迭代器）<span class="hljs-built_in">O</span> ( <span class="hljs-number">1</span> ) <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<br>s.<span class="hljs-built_in">rbegin</span>()返回逆序迭代器，指向容器元素最后一个位置<span class="hljs-built_in">O</span> ( <span class="hljs-number">1</span> ) <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<br>s.<span class="hljs-built_in">rend</span>()返回逆序迭代器，指向容器第一个元素前面的位置<span class="hljs-built_in">O</span> ( <span class="hljs-number">1</span> ) <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<br>s.<span class="hljs-built_in">clear</span>()删除set容器中的所有的元素,返回<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>类型<span class="hljs-built_in">O</span> ( N ) <span class="hljs-built_in">O</span>(N)<span class="hljs-built_in">O</span>(N)<br>s.<span class="hljs-built_in">empty</span>()判断set容器是否为空<span class="hljs-built_in">O</span> ( <span class="hljs-number">1</span> ) <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<br>s.<span class="hljs-built_in">insert</span>()插入一个元素<br>s.<span class="hljs-built_in">size</span>()返回当前set容器中的元素个数<span class="hljs-built_in">O</span> ( <span class="hljs-number">1</span> ) <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<br>s.<span class="hljs-built_in">erase</span>(iterator)删除定位器iterator指向的值<br>s.<span class="hljs-built_in">erase</span>(first,second）删除定位器first和second之间的值<br>s.<span class="hljs-built_in">erase</span>(key_value)删除键值key_value的值<br>查找<br>s.<span class="hljs-built_in">find</span>(element)查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器<br>s.<span class="hljs-built_in">count</span>(element)查找set中的元素出现的个数，由于set中元素唯一，此函数相当于查询element是否出现<br>s.<span class="hljs-built_in">lower_bound</span>(k)返回大于等于k的第一个元素的迭代器<span class="hljs-built_in">O</span> ( l o g N ) <span class="hljs-built_in">O</span>(logN)<span class="hljs-built_in">O</span>(logN)<br>s.<span class="hljs-built_in">upper_bound</span>(k)返回大于k的第一个元素的迭代器<span class="hljs-built_in">O</span> ( l o g N ) <span class="hljs-built_in">O</span>(logN)<span class="hljs-built_in">O</span>(logN)<br></code></pre></td></tr></table></figure><h2 id="7-3-访问"><a href="#7-3-访问" class="headerlink" title="7.3 访问"></a>7.3 访问</h2><p>智能指针访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it:s)&#123;<br>  cout&lt;&lt;it&lt;&lt;endl;<br>&#125;<span class="hljs-comment">//挨个访问</span><br><br>cout&lt;&lt;*s.<span class="hljs-built_in">rbegin</span>();<span class="hljs-comment">//访问最后一个元素</span><br></code></pre></td></tr></table></figure><h2 id="7-4-其他的一些set"><a href="#7-4-其他的一些set" class="headerlink" title="7.4 其他的一些set"></a>7.4 其他的一些set</h2><p>插眼</p><h1 id="8-tuple-元组"><a href="#8-tuple-元组" class="headerlink" title="8 tuple(元组)"></a>8 tuple(元组)</h1><h2 id="8-1"><a href="#8-1" class="headerlink" title="8.1"></a>8.1</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;tuple&gt;</span></span><br></code></pre></td></tr></table></figure><p>tuple模板是pair的泛化，可以封装不同类型任意数量的对象。</p><p>可以把tuple理解为pair的扩展，tuple可以声明二元组，也可以声明三元组。</p><p>tuple可以等价为结构体使用</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
